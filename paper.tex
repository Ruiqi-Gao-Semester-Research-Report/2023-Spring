%%%
%% This is file `sample-sigplan.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `sigplan')
%%
%% IMPORTANT NOTICE:
%%
%% For the copyright see the source file.
%%
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-sigplan.tex.
%%
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%%
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%%
%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0
%%
%%
%% The first command in your LaTeX source must be the \documentclass command.
%%\documentclass[sigplan,nonacm]{acmart}
\documentclass[sigplan, nonacm]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}

\graphicspath{{pictures/}}
%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
	\providecommand\BibTeX{{%
			\normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
%%\setcopyright{acmcopyright}
\setcopyright{none}
%%\acmJournal{PACMPL}
%%\acmVolume{1}
%%\acmNumber{CONF} % CONF = POPL or ICFP or OOPSLA
%%\acmArticle{1}
%%\acmYear{2021}
%%\acmMonth{9}
%%\acmDOI{}
%%\copyrightyear{2018}
%%\acmYear{2018}
%%\acmDOI{10.1145/1122445.1122456}

%% These commands are for a PROCEEDINGS abstract or paper.
%%\acmConference[Woodstock '18]{Woodstock '18: ACM Symposium%% on Neural
%%  Gaze Detection}{June 03--05, 2018}{Woodstock, NY}
%%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%%  June 03--05, 2018, Woodstock, NY}
%%\acmPrice{15.00}
%%\acmISBN{978-1-4503-XXXX-X/18/06}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}
\usepackage{xspace}
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[scaled=0.78]{beramono}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{stmaryrd}
%\usepackage{unicode-math}
%\usepackage{MnSymbol}
\usepackage{wasysym}
\usepackage{color}
\usepackage{xcolor,colortbl}
\usepackage{url}
\usepackage{listings}
\usepackage{paralist}
%\usepackage[compact]{titlesec}
\usepackage[font={small}]{caption}
\usepackage{wrapfig}
\usepackage{enumitem}
\usepackage{multicol}
\usepackage{multirow}
\usepackage{makecell}
\usepackage{flushend}
\usepackage{bcprules}
\usepackage{textcomp}
\usepackage{tikz}
\usetikzlibrary{positioning,fit,calc,arrows.meta,arrows,decorations}
\usepackage{pdfpages}
\usepackage{cleveref}
\usetikzlibrary{matrix}
\usepackage{xspace}
\definecolor{light-gray}{gray}{0.85}
\usepackage{stackengine}
\usepackage{mathpartir}
\input{macros}

%%
%% end of the preamble, start of the body of the document source.
\newcommand{\tool}{\textsc{GenSym}\xspace}
\newcommand{\klee}{\textsc{KLEE}\xspace}
\newcommand{\ul}[1]{\underline{#1}}
\newcommand{\lb}{\{~}
\newcommand{\rb}{~\}}

\newcommand{\Typ}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\Ast}[1]{\ensuremath{\textsf{\text{#1}}}}
\newcommand{\Def}[1]{\ensuremath{\mathrm{#1}}}
\newcommand{\mit}[1]{\ensuremath{\mathit{#1}}}
\newcommand{\msf}[1]{\ensuremath{\mathsf{#1}}}

\newcommand{\lang}{\textsf{SimpLLVM}\xspace}

\newcommand{\Sem}[3][]{\ensuremath{\llbracket {#2} \rrbracket_{#3}^{#1}}}
\newcommand{\SSem}[2]{\ensuremath{\llbracket {#1} \rrbracket_{#2}^{\#}}}
\newcommand{\State}{\mathbb{S}}
\newcommand{\Address}{\mathcal{A}}
\newcommand{\Mem}{\mathbb{M}}
\newcommand{\Value}{\mathcal{V}}
\newcommand{\Loc}{\msf{Loc}}
\begin{document}
\sloppy

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Provenance Tracking in Symbolic Execution}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Ruiqi Gao}
\email{gao606@purdue.edu}
\affiliation{%
  \institution{Purdue University}
  \city{Lafayette}
  \state{Indiana}
  \country{USA}
  \postcode{47901}
}

\begin{abstract}
%Provenance Tracking tracks the origin or source of an object. Pointer provenance, especially, tracks the creation, assignment, and any modifications to the pointer value. Reliable pointer provenance tracking can be used to check out-of-bound pointers, aliasing and other undefined behaviors and it useful in compiler optimizations. While there are existing work investigating provenance tracking for imperative language like C and LLVM IR, how to develop efficient provenance tracking for symbolic execution and its effects on the underlying memory model still remains under-explored. \par
Provenance tracking refers to the process of recording the origin or source of an object, which is particularly crucial for pointer variables in programming languages. Pointer provenance involves tracking the creation, assignment, and any modifications to a pointer value. Accurate pointer provenance tracking is useful in detecting and preventing undefined behaviors such as out-of-bounds pointers and aliasing, and it can also aid in compiler optimizations. \par

While previous research has explored provenance tracking for imperative languages like C and LLVM IR, there remains a lack of investigation into how to do efficient provenance tracking for symbolic execution and its effects on the underlying memory model. How a symbolic execution engine track pointer provenance also has direct affect on the strategies used to handle symbolic array access. In this paper, we will investigate two different provenance tracking techniques for symbolic execution, study their underlying memory model and strategies to handle symbolic array access. We further discuss how to go beyond pointer provenance tracking, and perform provenance tracking for all memory object and its potential application in symbolic execution.Finally, we will compare these two pointer provenance tracking techniques from two different symbolic execution engines, \klee and \tool.
\end{abstract}

\keywords{Provenance Tracking, Pointer Provenance, Symbolic Execution}

\maketitle

\section{Introduction}
Provenance tracking refers to the process of recording the origin or source of an object, which is particularly crucial for pointer variables in programming languages. The semantic of a pointer value for imperative languages is crucial for detecting undefined behaviors and has been well studied for C \cite{memarian2016into, memarian2019exploring} and LLVM \cite{lee2018reconciling}. Apart from low-level assembly, different languages have different memory model which restricts how the memory object can be modified. In order to identify undefined behaviors, effective provenance tracking must be performed. For example, low-level programming like C and LLVM use pointer arithmetic to construct a pointer into the middle of an object, however, whether constructing out-of-bound pointer is legal varies from specification to specification. Most imperative languages do not pose strict distinction between numeric types and pointer types at runtime. Therefore, casting between integers and pointer is allowed and need to be taken special care because the provenance information may get lost during the casting. Program analysis will reason about the abstract semantic of pointer values, and compiler optimization also relies on assumption on pointer provenance to perform radical optimizations.\par
Symbolic execution is a widely-used technique in software verification, bug-finding, and automatic test generation. First introduced in the 1970s \cite{boyer1975select, howden1977symbolic, king1975new, king1976symbolic}, symbolic execution enables the exploration of different execution paths simultaneously by making certain inputs symbolic and assigning each path a state. The state in a symbolic execution engine comprises two components: a set of boolean formulas that describe the path condition, and a symbolic memory store. Non divergent execution updates the symbolic store just as native execution. At branching point, the solver will be invoked to check the feasibility of both branches and fork if necessary. With the emergence of modern efficient SMT \cite{barrett2021satisfiability} solvers like Z3 \cite{moura2008z3}, symbolic execution becomes more efficient and is widely used in large-scale program testing.\par
Unlike native execution where pointer values are simple numeric data, all values in the symbolic execution are abstract as the execution is performed on top of a symbolic memory store. Each abstract value must record its primitive value, data width. For pointer value, the symbolic engine must also track their provenance information. The provenance information not only effect the memory security and optimization of the program, like in native execution. It is also vital to the correctness of the symbolic exploration as a symbolic array access can not be performed without correct pointer provenance tracking. As all values can be concrete or symbolic, using a symbolic index to access an array will become troublesome, and the symbolic engine's strategy to reason about this type of operation depends on how the provenance information is tracked. The approaches used to track the provenance information also direct affect the underlying memory design of the engine as the provenance information also need to fork at branching point. A scalable and efficient provenance tracking system can improve the performance of symbolic execution significantly.\par
\subsection{Paper Structure}
The paper is organized as follows: \par \par
In section \ref{nativeprovenance}, we will discuss the pointer provenance tracking for native execution and different approaches to track the provenance.\par
In section \ref{symbolicprovenance}, we will investigate two approaches of pointer provenance tracking for symbolic execution engine, their effect on the memory model design and symbolic array access strategies by comparing two symbolic engines, \klee \cite{cadar2008klee} and our work \tool.\par
In section \ref{fullprovenance}, we look at how can we scale beyond pointer provenance and track provenance for all object, its effect on the memory model and its applications.
In section \ref{evaluation}, we compare the performance of the two provenance tracking system using long-running symbolic execution experiments on Coreutils \cite{coreutilsweb}.\par
In section \ref{conclusion}, we summarize the work and draw some conclusions.

\section{Pointer provenance for native execution}\label{nativeprovenance}
Although pointer values will become simple numeric values at runtime, various complier analysis and optimization rely on the provenance tracking information of pointer values. For example, an aliasing analysis can use the provenance tracking information of two pointers to check whether they will alias and other compiler passes may be able to use the alias information to perform more radical optimizations. Accurate tracking of the pointer provenance tracking, however, remains a different problem to tackle. The fact that different language specification impose different restriction on the pointer provenance makes the problem more challenging. For example, two pointers may not be equivalent in some standards even if they have identical bite-wise representations. As the standard takes the abstract semantic of a pointer provenance into consideration, which imposes that two pointers based on different origins will never be equivalent.\par
To perform efficient tracking of the pointer provenance information is very difficult because imperative languages treat pointer values as numeric value at runtime and allow casting between pointers and integers and byte-wise manipulation. A memcpy function may break the provenance information of the pointer values it is copying. The provenance information must be preserved after those operation. Integer arithmetic also need to distinguish a primitive integer value from a casted integer value as the provenance information need to be preserved for the latter. Pointer arithmetic also adds difficulty to the tracking as provenance need to preserved during the arithmetic computation. Pointer arithmetic also will potentially create an out-of-bound pointer. The provenance information may also get broken when calling library function like fprintf and fscanf.\par
Previous work\cite{memarian2019exploring} defined two approaches to tracking provenance:
\begin{itemize}
  \item \textbf{PVI}: Provenance will be recorded for both integer value and pointer value. After a pointer-to-integer cast, the integer will carry the provenance information of the original pointer. During integer arithmetic, the result integer will reflect the provenance of the input if one of the input integer carries provenance information. During memcpy of pointer values, each byte of the pointer value will carry the original provenance. This approach will keep tracking the provenance for each value after casting and arithmetic computation.
  \item \textbf{PVNI}: Provenance will not be recorded after a pointer-to-integer cast. For a integer-to-pointer, the system will try to recover the provenance information by checking if the integer value lies within certain objects. If so, the casted pointer value will take the provenance of the object it points to.
\end{itemize}
PVI will give more accurate and restrictive provenance tracking but is more complex and difficult to implement. PVNI is a more simplified design but may perform an unsound tracking. For example, integer arithmetic on a casted pointer may create a out-of-bound pointer that lies within another object. Some undefined behaviors in PVI will become legal in PVNI, therefore cause the compiler to perform unsecure optimizations.
\section{Pointer provenance for symbolic execution}\label{symbolicprovenance}
For symbolic execution tasks, pointer provenance tracking plays a different role than native execution. For native execution, pointer value is simple numeric data at runtime, and the pointer provenance is only used at compiler-time for analysis and optimization. For symbolic execution, aside from the above applications, pointer provenance also severs as the basic for performing symbolic array access.\par
In Figure \ref{fig:example}, we are reading the array a with a symbolic index and use it in a condition for if statement. If we do not track the provenance of pointer p, we can not continue the exploration as the object that p points to and its the size are unknown, we will be unable to perform an array read. We also can not explore out-of-bound cases (an error) and generate a test for that.
\begin{figure}[t]
  \centering
  \begin{subfigure}{0.8\textwidth}
  \begin{lstlisting}[style=small,language=C,numbers=left,stepnumber=1,xleftmargin=2em,numberstyle=\ttfamily][mathescape]
  int main() {
    int a[4] = {0, 1, 2, 3};
    int * p = a;
    int index;
    make_symbolic(&index, sizeof(index));
    if (p[index] < 2) {
      // Some computation
    } else {
      // Some computation
    }
  }
  \end{lstlisting}
  %\vspace{-1em}
  %\caption{The generated code of the LLVM \texttt{power} function by \tool.
  \end{subfigure}
  \caption{An example of symbolic array access.}
  %\vspace{-0.3in}
  \label{fig:example}
  \end{figure}
We summarize two approaches for pointer provenance tracking for symbolic execution
\begin{itemize}
  \item \textbf{Provenance By Engine}: Pointer value itself does not carry any provenance information in its value representation. A pointer value can be treated the same as a integer value with the same bit-wise data. The provenance information will be recovered upon dereferencing the pointer (a memory read/write). For concrete index, we can easily located the object it points to. For symbolic index, we will need to scan all objects and enumerate all possible provenance. This is similar to \textbf{PVNI} in native execution.
  \item \textbf{Provenance By Value}: As values in symbolic execution are abstract values, they can carry additional meta data inside. Pointer values can carry its provenance (origin object's base and range) as part of its metadata. And the provenance will be carried as the value is passed around. Upon pointer-to-integer casting, the casted integer value will also carry the original pointer's provenance. If we perform byte-level access of the pointer value, each pointer will carry the provenance info as well. This is similar to \textbf{PVI} in native execution.
\end{itemize}
Different pointer provenance tracking in symbolic execution favors different symbolic memory model design and strategies to perform symbolic array access. In short, Provenance By Value can be adopted to flat memory model where the entire memory is a linear vector, and the engine does not need to store object's metadata. All memory objects' metadata will stored inside pointers that points to them.  Provenance By Engine, on the other hand, requires an object-by-object memory model where all the objects and their meta data are stored separately so that the provenance can be recovered at memory access. \klee uses Provenance By Engine while our work \tool uses Provenance By value. In the following subsections, we will use this two engines as example to compare these two Provenance tracking approaches and their effect on symbolic execution engine designs.
\subsection[]{Provenance By Engine}
Provenance By Engine does not carry pointer's provenance inside each value, a pointer value is the same as an integer value. Pointer values can be manipulated the same way as integer for arithmetic, byte-level manipulation. The provenance will only be recovered at dereferencing, the engine will check all live objects to enumerate all possible objects it points to, therefore recovering the provenance information.\par
This provenance tracking approach only works if we have an object-by-object memory model, manage each object and its metadata separately, and fork the metadata corresponding when branching. If we do not store each object's metadata, we will nor be able to recover the pointer's provenance at memory access point. This object-by-object memory model then supports different ways to reason about symbolic array access. As objects are stored separately, we can further record both its concrete store and update history inside the object's representation, the later will enable us to use SMT array theory to for better solver performance. SMT solver has imbedded support for array theory, which support array read and write as part of its input query. However, to use the SMT array theory, we will need to keep a list of the object's update history, which can only work in a object-by-object memory model.\par
\klee is a symbolic execution engine that adopts Provenance By Engine. The memory store is a collection of objects, each contain a concrete store and an update history list. Object may be copied at forking point to allow separate exploration of both paths. Each object correspond to an array in backend SMT solver. As in Provenance By Engine, pointer value does not carry additional provenance information and are equivalent to integer values. Upon memory access, the engine will check all objects to check all potential objects. For a symbolic index, the engine will generate a simple SMT array read expression on the corresponding object as the result. For example, the array access in Figure \ref{fig:example} will generate a single $array\_read(a, index)$. All the reasoning about this symbolic array read will be handled by the underlying solver, for example, STP and Z3. Since array theory is included in modern SMT solvers, the solver already have sophisticated optimizations to simplify the array read when this expression is used in later queries. Also, the simple query structure will save time in solver chain optimizations like constraint independent solving and caching.
\subsection[short]{Provenance By Value}
Provenance By Value records the provenance information inside the value representation, including the object it points to and the object's metadata. Pointer value is different from integer value as it carries additional information, and need to be handled specially even after been casted to integers. Pointer-to-integer cast will keep the original provenance information, same happens for byte-level extraction of pointer values.\par
Since all the provenance information of an object is stored in the pointer that references it, we no longer need to store and maintain the object metadata during execution. This gives us more flexibility in the memory model design. Apart from an object-by-object memory model which is difficult to program and maintain as it needs to handle efficient forking. We can just use a flat memory model, and use a linear vector to represent the entire memory. All the object are stored together inside the vector. By choosing some persistent data structure that support copy-on-write and sharing natively, like immer's flex vector\cite{puente2017persistence} to store the flat memory region, we can get an efficient memory model that support forking for free.\par
While Provenance By Value gives us more flexibility in developing the underlying memory model, it increases complexity in the execution of normal arithmetic instructions as the engine need to distinguish an integer with no provenance from a primitive integer and handle them separately. It also effect the reasoning strategies for symbolic array access which we will discuss later.\par
Our work \tool uses Provenance By Value and a flat memory model. Since the memory model is not object-by-object and we do not store objects' metadata separately, we have a different strategies to handle symbolic array access. Since the entire memory is just a large vector and we no longer keep each object's metadata separately, we can no longer keep a update history of each object. Therefore, we can not use SMT's embedded array support and need to handle a symbolic array access in a different way. As we record the pointer's provenance inside its value representation, we can use other SMT constructs to reason about array access. \tool supports two strategies for this:
\begin{itemize}
  \item \textbf{Check All Index}: Using the provenance information carried by the pointer, we can can check all possible inbound index positions and use SMT's embedded if-then-else (ite for short) expression to faithfully represent a symbolic array access. For example, for the program in Figure \ref{fig:example}, in the condition expression, the engine will return a complex ite expression: \par ite(index == 0, a[0], ite(index == 1, a[1], ite(index == 2, a[2], ite(index == 3, a[3], poison)))). \par
  The engine will enumerate all possible index position, fetching the corresponding value, and guard each value with the corresponding condition (sym\_index == position) and return a recursive ite expression. The expression will faithfully represent the result of a symbolic read on the array.
  \item \textbf{Check Only Feasible Index}: This approach is similar to the above method, the only difference is that instead of enumerating all index positions, this method will invoke the solver to get the set of feasible values of the current index, and generate the ite expression with only the feasible positions. This method will generate a much more simplified expression but will incur solver overhead. For a symbolic array read on array a with symbolic index, the result will be: \par ite(index == feasible\_val0, a[feasible\_val0], ite(index == feasible\_val1, a[feasible\_val1], $\dots$)). \par
\end{itemize}
Both approaches have their pros and cons: \par Check All Index has no solver overhead but will generate more complex expression, which may put pressure on the query solving in the future if the result expression appear in later query. It may also slow down the later solver chain optimization like constraint independence solving and query simplification.\par
Check Only Feasible Index on the other hand, will generate much simpler ite expressions but may will add additional solver overhead during memory access.\par
Provenance By Engine and Provenance By Value have different effect on the underlying effect on the memory model and its strategies to reason about symbolic arrays. Provenance By Engine requires a object-by-object model which is difficult to engineer and need additional resolving time at memory access, but support SMT's array theory for fre and generate simpler queries. Provenance By Value enables more flexibility in memory model design and support flat memory model, but have many special cases to handle for scalar instruction and will generate more complex expressions.
\section{Full provenance tracking for symbolic execution}\label{fullprovenance}
Aside from only tracking provenance information for pointers, we can also scale to full provenance tracking for all memory objects and their modification. By having a memory model that aligns with the program structure, and keep full provenance for all memory object, we can easily roll back some operations and efficient merge memories at different program points. This is particularly useful for state merging in symbolic execution.\par
State merging is a technique for symbolic execution to address the state-explosion where the path number in symbolic execution explorations increases exponentially. State merging will try to merge two paths at the same program points if their memory store is similar to each other. The design of the engine's memory model will significantly affect the efficiency of state merging. Existing approach either use ite expression to traverse and merge each object \cite{kuznetsov2012efficient}, this approach is time consuming when merging two states. Other approach \cite{coppa2017rethinking} treats the memory model as an large list of memory update with timestamp. This type of memory model natively support quick merging of states by traverse the update list and only merge the after the divergent timestamp. However, this kind of memory has poor performance when executing normal memory operation, even with some smart optimization like value-range checks, as each memory access need to go through the entire update list.\par
If we can have a memory model based on full provenance tracking for all memory objects, and faithfully and efficiently record the update along the execution, both normal execution and state merging will become more efficient. For example, after a simple star shaped program with a if-then-else expression reach the same program point after the divergence, the two states only need to merge the tracked updates inside the if-then-else expressions, while keep share the old memory state before the divergence. Using some smart designs from persistent data structure, we can have a memory model that achieve maximum sharing among states while record the update and provenance of each object. %Provenance tracking can also aid static state merging by transforming loops into simpler representation via structured heaps \cite{essertel2019precise}.\par
\section{Evaluation}\label{evaluation}
\input{table.tex}
In this section, we use coreutils test suites as a benchmark to compare the two the Provenance Tracking systems mentioned in \ref{symbolicprovenance} by comparing \klee (Provenance By Engine) with \tool (Provenance By Value). We use same number of symbolic arguments and compare their query/solver time. \tool uses Check All Index strategy to handle symbolic array read. As in Check Only Feasible Index strategy,  we need can only get one feasible assignment for each query. To get all feasible assignments, we need to iteratively get one feasible assignment in the current path condition, stores it in the result set, and negating the current feasible assignment and add it to path condition and repeat to get the next feasible assignment until the path condition becomes unfeasible. Therefore one array access query may trigger multiple queries to the solver and causing a significant solver overhead. The performance maybe improved if the solver has embedded support to return all feasible assignment set or its range of a value in a single query or the solver caching adds support to this. At the current time, we find that Check All Index strategy is more efficient for large complex input program.\par
From table \ref{tab:bench_coreutils}, we can observe that \tool with Provenance By Value spends more time on the actual query solving as well as the solver chain optimizations as we discussed in Section \ref{symbolicprovenance}. This is caused by the fact that Provenance By Value returns more complex expression for symbolic array read, which add additional pressure to the solver chain optimization as multiple solver chain optimizations will perform analysis and simplification on the query expression. Actual querying time will also increase because the backend SMT solver like STP and Z3 have a series of internal query transformation/optimization, and complex expression will incur more overhead.\par
We can also observe that \klee with Provenance By Engine spends more time in the concrete execution. This is part caused by different approaches to perform the symbolic execution, where \klee uses interpretation and \tool uses compilation. But also \klee also needs to recover the pointer's provenance at each memory access operation, which requires inspection of all memory object to check whether the pointer lies inbound. The adds additional execution overhead. The object-by-object memory model required by Provenance By Engine model also require additional maintenance of the memory objects and their metadata at forking point to realize isolation and sharing between the old state and the forked state.\par
The experiments result is consistent with our observation in Section \ref{symbolicprovenance}.
\section{Conclusion}\label{conclusion}
In this paper, we discuss two different approaches to tracking pointer provenance for symbolic execution. Tracking provenance by value gives us more flexibility in memory model design, while tracking provenance by Engine do not need to handle special cases of integers casted from pointers for arithmetic operation. We further discussed how full provenance tracking can improve state-merging performance for symbolic execution. We use evaluation benchmarks to compare the two Provenance Tracking systems for symbolic execution tasks.
%\newpage
\bibliographystyle{acm}
\bibliography{paper}
\end{document}
\endinput
